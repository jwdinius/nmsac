//! c/c++ headers
#include <string>
#include <fstream>
#include <memory>
#include <streambuf>
//! googletest
#include "gtest/gtest.h"
//! dependency headers
#include "TestData.h"  // unit test configuration data (generated by CMake)
#include <nlohmann/json.hpp>
//! unit-under-test header
#include "correspondences/mc/mc.hpp"

namespace cor = correspondences;
namespace cg = cor::graph;
namespace cm = cor::mc;

using json = nlohmann::json;

//! The fixture for testing class mc.
class MCTest : public ::testing::Test {
 protected:
   /**
    * constants for test
    */
   // You can remove any or all of the following functions if their bodies would
   // be empty.

   MCTest() : data_path_(DATA_PATH) {
     // You can do set-up work for each test here.
   }

   ~MCTest() override {
     // You can do clean-up work that doesn't throw exceptions here.
   }

   // If the constructor and destructor are not enough for setting up
   // and cleaning up each test, you can define the following methods:

   void SetUp() override {
     // Code here will be called immediately after the constructor (right
     // before each test).
   }

   void TearDown() override {
     // Code here will be called immediately after each test (right
     // before the destructor).
   }

   // Class members declared here can be used by all tests in the test suite
   // for Foo.
   const std::string data_path_;
};

TEST_F(MCTest, FullSourceMatchingBasic) {
  //! load unit test data from json
  //! NOTE: this test data was generated without adding noise
  std::ifstream ifs(data_path_ + "/registration-data.json");
  std::string json_str = std::string((std::istreambuf_iterator<char>(ifs)),
      std::istreambuf_iterator<char>());
  json json_data = json::parse(json_str);

  //! setup configuration struct for test
  //! @note this algorithm is very sensitive to the epsilon and pairwise_dist_threshold settings!!
  cm::Config config;
  config.epsilon = 0.015;
  config.pairwise_dist_threshold = 0.015;
  config.algo = cg::max_clique_algo_e::bnb_basic;

  //! source pts (read first so that we can use min_corr == no. of source points)
  auto const rows_S = json_data["source_pts"].size();
  auto const cols_S = json_data["source_pts"][0].size();
  size_t i = 0;
  arma::mat src_pts(rows_S, cols_S);
  for (auto const & it : json_data["source_pts"]) {
    size_t j = 0;
    for (auto const & jt : it) {
      src_pts(i, j) = static_cast<double>(jt);
      ++j;
    }
    ++i;
  }

  //! target pts
  auto const rows_T = json_data["target_pts"].size();
  auto const cols_T = json_data["target_pts"][0].size();
  i = 0;
  arma::mat tgt_pts(rows_T, cols_T);
  for (auto const & it : json_data["target_pts"]) {
    size_t j = 0;
    for (auto const & jt : it) {
      tgt_pts(i, j) = static_cast<double>(jt);
      ++j;
    }
    ++i;
  }

  //! correspondences
  i = 0;
  cor::correspondences_t _corrs;
  for (auto const & it : json_data["correspondences"]) {
    auto key = std::make_pair(i, static_cast<size_t>(it));
    _corrs[key] = 1;
    ++i;
  }

  cor::correspondences_t corrs;
  std::unique_ptr<cor::CorrespondencesBase> mc = std::make_unique<cor::MC>(
      src_pts, tgt_pts, config);
  ASSERT_TRUE( mc->calc_correspondences(corrs) == cor::status_e::success );

  /**
   * checking that key is present in both correspondence sets is enough;
   * @see find_correspondences
   * @note this algorithm does not give a confidence score, so 1 is set by default
   */
  ASSERT_TRUE( corrs == _corrs );
}

TEST_F(MCTest, PartialSourceMatchingBasic) {
  //! load unit test data from json
  //! NOTE: this test data was generated without adding noise
  std::ifstream ifs(data_path_ + "/registration-data-mincorr.json");
  std::string json_str = std::string((std::istreambuf_iterator<char>(ifs)),
      std::istreambuf_iterator<char>());
  json json_data = json::parse(json_str);

  //! setup configuration struct for test
  //! @note this algorithm is very sensitive to the epsilon and pairwise_dist_threshold settings!!
  cm::Config config;
  config.epsilon = 0.015;
  config.pairwise_dist_threshold = 0.015;
  config.algo = cg::max_clique_algo_e::bnb_basic;

  //! source pts (read first so that we can use min_corr == no. of source points)
  auto const rows_S = json_data["source_pts"].size();
  auto const cols_S = json_data["source_pts"][0].size();
  size_t i = 0;
  arma::mat src_pts(rows_S, cols_S);
  for (auto const & it : json_data["source_pts"]) {
    size_t j = 0;
    for (auto const & jt : it) {
      src_pts(i, j) = static_cast<double>(jt);
      ++j;
    }
    ++i;
  }

  //! target pts
  auto const rows_T = json_data["target_pts"].size();
  auto const cols_T = json_data["target_pts"][0].size();
  i = 0;
  arma::mat tgt_pts(rows_T, cols_T);
  for (auto const & it : json_data["target_pts"]) {
    size_t j = 0;
    for (auto const & jt : it) {
      tgt_pts(i, j) = static_cast<double>(jt);
      ++j;
    }
    ++i;
  }

  //! correspondences
  i = 0;
  cor::correspondences_t _corrs;
  for (auto const & it : json_data["correspondences"]) {
    auto key = std::make_pair(i, static_cast<size_t>(it));
    _corrs[key] = 1;
    ++i;
  }

  cor::correspondences_t corrs;
  std::unique_ptr<cor::CorrespondencesBase> mc = std::make_unique<cor::MC>(
      src_pts, tgt_pts, config);
  ASSERT_TRUE( mc->calc_correspondences(corrs) == cor::status_e::success );

  /**
   * checking that key is present in both correspondence sets is enough;
   * @see find_correspondences
   * @note this algorithm does not give a confidence score, so 1 is set by default
   */
  ASSERT_TRUE( corrs == _corrs );
}

TEST_F(MCTest, FullSourceMatchingColor) {
  //! load unit test data from json
  //! NOTE: this test data was generated without adding noise
  std::ifstream ifs(data_path_ + "/registration-data.json");
  std::string json_str = std::string((std::istreambuf_iterator<char>(ifs)),
      std::istreambuf_iterator<char>());
  json json_data = json::parse(json_str);

  //! setup configuration struct for test
  //! @note this algorithm is very sensitive to the epsilon and pairwise_dist_threshold settings!!
  cm::Config config;
  config.epsilon = 0.015;
  config.pairwise_dist_threshold = 0.015;
  config.algo = cg::max_clique_algo_e::bnb_color;

  //! source pts (read first so that we can use min_corr == no. of source points)
  auto const rows_S = json_data["source_pts"].size();
  auto const cols_S = json_data["source_pts"][0].size();
  size_t i = 0;
  arma::mat src_pts(rows_S, cols_S);
  for (auto const & it : json_data["source_pts"]) {
    size_t j = 0;
    for (auto const & jt : it) {
      src_pts(i, j) = static_cast<double>(jt);
      ++j;
    }
    ++i;
  }

  //! target pts
  auto const rows_T = json_data["target_pts"].size();
  auto const cols_T = json_data["target_pts"][0].size();
  i = 0;
  arma::mat tgt_pts(rows_T, cols_T);
  for (auto const & it : json_data["target_pts"]) {
    size_t j = 0;
    for (auto const & jt : it) {
      tgt_pts(i, j) = static_cast<double>(jt);
      ++j;
    }
    ++i;
  }

  //! correspondences
  i = 0;
  cor::correspondences_t _corrs;
  for (auto const & it : json_data["correspondences"]) {
    auto key = std::make_pair(i, static_cast<size_t>(it));
    _corrs[key] = 1;
    ++i;
  }

  cor::correspondences_t corrs;
  std::unique_ptr<cor::CorrespondencesBase> mc = std::make_unique<cor::MC>(
      src_pts, tgt_pts, config);
  ASSERT_TRUE( mc->calc_correspondences(corrs) == cor::status_e::success );

  /**
   * checking that key is present in both correspondence sets is enough;
   * @see find_correspondences
   * @note this algorithm does not give a confidence score, so 1 is set by default
   */
  ASSERT_TRUE( corrs == _corrs );
}

TEST_F(MCTest, PartialSourceMatchingColor) {
  //! load unit test data from json
  //! NOTE: this test data was generated without adding noise
  std::ifstream ifs(data_path_ + "/registration-data-mincorr.json");
  std::string json_str = std::string((std::istreambuf_iterator<char>(ifs)),
      std::istreambuf_iterator<char>());
  json json_data = json::parse(json_str);

  //! setup configuration struct for test
  //! @note this algorithm is very sensitive to the epsilon and pairwise_dist_threshold settings!!
  cm::Config config;
  config.epsilon = 0.015;
  config.pairwise_dist_threshold = 0.015;
  config.algo = cg::max_clique_algo_e::bnb_color;

  //! source pts (read first so that we can use min_corr == no. of source points)
  auto const rows_S = json_data["source_pts"].size();
  auto const cols_S = json_data["source_pts"][0].size();
  size_t i = 0;
  arma::mat src_pts(rows_S, cols_S);
  for (auto const & it : json_data["source_pts"]) {
    size_t j = 0;
    for (auto const & jt : it) {
      src_pts(i, j) = static_cast<double>(jt);
      ++j;
    }
    ++i;
  }

  //! target pts
  auto const rows_T = json_data["target_pts"].size();
  auto const cols_T = json_data["target_pts"][0].size();
  i = 0;
  arma::mat tgt_pts(rows_T, cols_T);
  for (auto const & it : json_data["target_pts"]) {
    size_t j = 0;
    for (auto const & jt : it) {
      tgt_pts(i, j) = static_cast<double>(jt);
      ++j;
    }
    ++i;
  }

  //! correspondences
  i = 0;
  cor::correspondences_t _corrs;
  for (auto const & it : json_data["correspondences"]) {
    auto key = std::make_pair(i, static_cast<size_t>(it));
    _corrs[key] = 1;
    ++i;
  }

  cor::correspondences_t corrs;
  std::unique_ptr<cor::CorrespondencesBase> mc = std::make_unique<cor::MC>(
      src_pts, tgt_pts, config);
  ASSERT_TRUE( mc->calc_correspondences(corrs) == cor::status_e::success );

  /**
   * checking that key is present in both correspondence sets is enough;
   * @see find_correspondences
   * @note this algorithm does not give a confidence score, so 1 is set by default
   */
  ASSERT_TRUE( corrs == _corrs );
}
